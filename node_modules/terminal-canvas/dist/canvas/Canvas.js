"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Canvas = void 0;
const Color_1 = require("../color/Color");
const Cell_1 = require("../cell/Cell");
const encodeToVT100_1 = require("../encodeToVT100");
class Canvas {
    constructor(options) {
        this.stream = process.stdout;
        this.cursorX = 0;
        this.cursorY = 0;
        this.cursorBackground = { r: -1, g: -1, b: -1 };
        this.cursorForeground = { r: -1, g: -1, b: -1 };
        this.cursorDisplay = {
            blink: false,
            bold: false,
            dim: false,
            hidden: false,
            reverse: false,
            underlined: false,
        };
        if (typeof (options === null || options === void 0 ? void 0 : options.stream) !== 'undefined') {
            this.stream = options.stream;
        }
        this.width = this.stream.columns;
        if (typeof (options === null || options === void 0 ? void 0 : options.width) !== 'undefined') {
            this.width = options.width;
        }
        this.height = this.stream.rows;
        if (typeof (options === null || options === void 0 ? void 0 : options.height) !== 'undefined') {
            this.height = options.height;
        }
        this.cells = Array
            .from({ length: this.width * this.height })
            .map((_, index) => new Cell_1.Cell(' ', { x: this.getXYFromPointer(index)[0], y: this.getXYFromPointer(index)[1] }));
        this.lastFrame = Array.from({ length: this.width * this.height }).fill('');
    }
    static create(options) {
        return new this(options);
    }
    write(data) {
        const { width, height } = this;
        const background = this.cursorBackground;
        const foreground = this.cursorForeground;
        const display = this.cursorDisplay;
        for (const char of data) {
            const x = this.cursorX;
            const y = this.cursorY;
            const pointer = this.getPointerFromXY(x, y);
            if (x >= 0 && x < width && y >= 0 && y < height) {
                const cell = this.cells[pointer];
                cell.setChar(char);
                cell.setX(x);
                cell.setY(y);
                cell.setBackground(background.r, background.g, background.b);
                cell.setForeground(foreground.r, foreground.g, foreground.b);
                cell.setDisplay(display);
                cell.isModified = true;
            }
            this.cursorX += 1;
        }
        return this;
    }
    flush() {
        let payload = '';
        for (let i = 0; i < this.cells.length; i += 1) {
            const cell = this.cells[i];
            if (cell.isModified) {
                cell.isModified = false;
                const cellSeq = cell.toString();
                if (cellSeq !== this.lastFrame[i]) {
                    this.lastFrame[i] = cellSeq;
                    payload += cellSeq;
                }
            }
        }
        this.stream.write(payload);
        return this;
    }
    getPointerFromXY(x = this.cursorX, y = this.cursorY) {
        return y * this.width + x;
    }
    getXYFromPointer(index) {
        return [index - Math.floor(index / this.width) * this.width, Math.floor(index / this.width)];
    }
    up(y = 1) {
        this.cursorY -= Math.floor(y);
        return this;
    }
    down(y = 1) {
        this.cursorY += Math.floor(y);
        return this;
    }
    right(x = 1) {
        this.cursorX += Math.floor(x);
        return this;
    }
    left(x = 1) {
        this.cursorX -= Math.floor(x);
        return this;
    }
    moveBy(x, y) {
        if (x < 0)
            this.left(-x);
        if (x > 0)
            this.right(x);
        if (y < 0)
            this.up(-y);
        if (y > 0)
            this.down(y);
        return this;
    }
    moveTo(x, y) {
        this.cursorX = Math.floor(x);
        this.cursorY = Math.floor(y);
        return this;
    }
    foreground(color) {
        this.cursorForeground = color === 'none' ? { r: -1, g: -1, b: -1 } : Color_1.Color.create(color).toRgb();
        return this;
    }
    background(color) {
        this.cursorBackground = color === 'none' ? { r: -1, g: -1, b: -1 } : Color_1.Color.create(color).toRgb();
        return this;
    }
    bold(isBold = true) {
        this.cursorDisplay.bold = isBold;
        return this;
    }
    dim(isDim = true) {
        this.cursorDisplay.dim = isDim;
        return this;
    }
    underlined(isUnderlined = true) {
        this.cursorDisplay.underlined = isUnderlined;
        return this;
    }
    blink(isBlink = true) {
        this.cursorDisplay.blink = isBlink;
        return this;
    }
    reverse(isReverse = true) {
        this.cursorDisplay.reverse = isReverse;
        return this;
    }
    hidden(isHidden = true) {
        this.cursorDisplay.hidden = isHidden;
        return this;
    }
    erase(x1, y1, x2, y2) {
        var _a;
        for (let y = y1; y <= y2; y += 1) {
            for (let x = x1; x <= x2; x += 1) {
                const pointer = this.getPointerFromXY(x, y);
                (_a = this.cells[pointer]) === null || _a === void 0 ? void 0 : _a.reset();
            }
        }
        return this;
    }
    eraseToEnd() {
        return this.erase(this.cursorX, this.cursorY, this.width - 1, this.cursorY);
    }
    eraseToStart() {
        return this.erase(0, this.cursorY, this.cursorX, this.cursorY);
    }
    eraseToDown() {
        return this.erase(0, this.cursorY, this.width - 1, this.height - 1);
    }
    eraseToUp() {
        return this.erase(0, 0, this.width - 1, this.cursorY);
    }
    eraseLine() {
        return this.erase(0, this.cursorY, this.width - 1, this.cursorY);
    }
    eraseScreen() {
        return this.erase(0, 0, this.width - 1, this.height - 1);
    }
    saveScreen() {
        this.stream.write(encodeToVT100_1.encodeToVT100('[?47h'));
        return this;
    }
    restoreScreen() {
        this.stream.write(encodeToVT100_1.encodeToVT100('[?47l'));
        return this;
    }
    hideCursor() {
        this.stream.write(encodeToVT100_1.encodeToVT100('[?25l'));
        return this;
    }
    showCursor() {
        this.stream.write(encodeToVT100_1.encodeToVT100('[?25h'));
        return this;
    }
    reset() {
        this.stream.write(encodeToVT100_1.encodeToVT100('c'));
        return this;
    }
}
exports.Canvas = Canvas;
//# sourceMappingURL=Canvas.js.map